**限制并发（如 maxConcurrency: 200）不是为了“慢”，而是为了“稳且快”** —— 通过背压控制，让磁盘、线程池、系统资源始终处于高效且不过载的最佳状态，最终实现整体性能最大化。



```js
// 核心配置
const MAX_CONCURRENCY = 200; // 最大并发数限制

// 核心遍历函数
async function scanWithConcurrencyQueue(rootDir) {
    const queue = [];          // 任务队列 (存放待处理的文件夹)
    let activePromises = 0;    // 当前正在运行的任务数
    
    // 用于控制整体流程结束的 Promise
    let resolveFinish;
    let rejectFinish;
    const finishPromise = new Promise((res, rej) => {
        resolveFinish = res;
        rejectFinish = rej;
    });

    // --- 消费者：任务调度器 ---
    const processQueue = async () => {
        // 核心循环：当队列有任务 且 当前并发数未满 时，继续派发任务
        while (queue.length > 0 && activePromises < MAX_CONCURRENCY) {
            activePromises++; // 占用一个并发槽位
            
            const task = queue.shift(); // 取出一个任务
            
            // 执行任务
            task().finally(() => {
                activePromises--; // 任务完成，释放槽位
                processQueue();   // 递归调用，尝试处理下一个任务
                
                // 检查是否所有任务全做完了
                if (activePromises === 0 && queue.length === 0) {
                    resolveFinish();
                }
            }).catch(rejectFinish);
        }
    };

    // --- 生产者：初始任务 ---
    // 将根目录的处理函数放入队列
    queue.push(() => processDirectory(rootDir, queue));
    
    // 启动引擎
    processQueue();
    
    // 等待全部完成
    await finishPromise;
}

// 具体的工作任务
async function processDirectory(currentPath, queue) {
    try {
        // 1. 异步读取目录 (I/O 操作)
        const items = await fs.promises.readdir(currentPath, { withFileTypes: true });
        
        for (const item of items) {
            const fullPath = path.join(currentPath, item.name);
            
            if (item.isDirectory()) {
                // 2. 发现新目录 -> 生产新任务 -> 推入队列
                queue.push(() => processDirectory(fullPath, queue));
            } else if (item.isFile()) {
                // 3. 发现文件 -> 直接处理 (或者也可以放入另一个文件处理队列)
                // await processFile(fullPath); 
            }
        }
    } catch (error) {
        console.warn(`读取失败: ${currentPath}`);
    }
}
```

