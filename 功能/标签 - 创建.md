## 解决的问题

1. **内容描述需求**：为视频内容提供超越文件名的丰富描述
2. **精准检索需求**：实现基于内容的精确搜索，而非模糊文件名匹配
3. **多维分类需求**：支持多维度、灵活的内容组织和分类
4. **视觉标记需求**：对特定画面区域进行精确标注和引用



### 1. 图片标签创建

**触发方式**：鼠标框选 + 快捷键

```
class ImageTagCreator {
  async createImageTag(selection: SelectionArea, videoInfo: VideoContext): Promise<ImageTag> {
    // 1. 捕获框选区域的截图
    const screenshot = await this.captureSelectionArea(selection, videoInfo);
    
    // 2. 弹出标签创建对话框
    const tagData = await this.showTagDialog(screenshot, selection);
    
    // 3. 生成唯一ID并保存
    const tagId = this.generateTagId();
    const imageTag: ImageTag = {
      tag_id: tagId,
      tag_type: 'image',
      name: tagData.primaryDescription,
      group: tagData.group,
      created_time: new Date(),
      created_by: 'current_user',
      video_files: [videoInfo.hash],
      image_data: {
        source_video: videoInfo.hash,
        timestamp: videoInfo.currentTime,
        bounding_box: selection,
        image_path: screenshot.path
      },
      descriptions: tagData.descriptions
    };
    
    // 4. 保存到tags.json并关联视频
    await this.saveTagAndAssociateVideo(imageTag, videoInfo.hash);
    
    return imageTag;
  }
}
```

### 2. 文本标签创建

**触发方式**：快捷键打开创建对话框

```
class TextTagCreator {
  async createTextTag(videoInfo: VideoContext): Promise<TextTag> {
    // 1. 弹出文本标签对话框
    const tagData = await this.showTextTagDialog();
    
    // 2. 创建文本标签
    const tagId = this.generateTagId();
    const textTag: TextTag = {
      tag_id: tagId,
      tag_type: 'text', 
      name: tagData.name,
      group: tagData.group,
      created_time: new Date(),
      created_by: 'current_user',
      video_files: [videoInfo.hash],
      text: tagData.text
    };
    
    // 3. 保存并关联
    await this.saveTagAndAssociateVideo(textTag, videoInfo.hash);
    
    return textTag;
  }
}
```

### 3. 标签分配界面

**搜索与分配流程**：

```
class TagAssignment {
  async assignTagToVideo(videoHash: string): Promise<void> {
    // 1. 打开标签分配对话框
    const dialog = this.openAssignmentDialog();
    
    // 2. 实时搜索过滤
    dialog.onInputChange((searchText) => {
      const filteredTags = this.filterTags(searchText);
      this.updateTagDisplay(filteredTags);
    });
    
    // 3. 处理选择
    dialog.onTagSelect((tagId) => {
      await this.associateTagWithVideo(tagId, videoHash);
      dialog.refresh(); // 更新显示
    });
    
    // 4. 处理创建新标签
    dialog.onCreateNew((tagData) => {
      const newTag = await this.createNewTag(tagData);
      await this.associateTagWithVideo(newTag.tag_id, videoHash);
    });
  }
}
```

## UI设计

### 标签创建对话框

```
[图片标签对话框布局]
┌─────────────────────────────────────┐
│  [截图预览区域]   [输入控制区域]       │
│  ┌─────────────┐  ┌─────────────┐  │
│  │             │  │ 描述1: [___]  │  │
│  │  框选图片    │  │ 描述2: [___]  │  │
│  │             │  │ 描述3: [___]  │  │
│  └─────────────┘  │ 分组: [▽]     │  │
│                   └─────────────┘  │
│                   [确定] [取消]      │
└─────────────────────────────────────┘
```

### 标签分配界面

```
[标签分配对话框布局]
┌─────────────────────────────────────┐
│ 搜索框: [_________________________]   │
├─────────────────────────────────────┤
│  [分组列表]      [标签展示区域]         │
│  ┌─────────┐    ┌─────────────────┐ │
│  │ 分组A   │    │ 匹配的图片标签    │ │
│  │ 分组B   │    │ ┌─┐ ┌─┐ ┌─┐     │ │
│  │ 分组C   │    │ │ │ │ │ │ │     │ │
│  └─────────┘    │ └─┘ └─┘ └─┘     │ │
│                 │                 │ │
│                 │ 匹配的文本标签    │ │
│                 │ [标签1] [标签2]   │ │
│                 └─────────────────┘ │
└─────────────────────────────────────┘
```

## 操作流程

### 图片标签创建流程

1. **框选区域**：鼠标拖拽选择视频画面区域
2. **弹出对话框**：自动显示标签创建界面
3. **输入描述**：主描述（第一个输入框）Tab键添加更多描述（最多5个）Ctrl+V粘贴图片URL（替换截图）
4. **选择分组**：从下拉列表选择或输入新分组
5. **确认创建**：Enter键或点击确定按钮

### 标签分配流程

1. **打开分配界面**：快捷键触发
2. **搜索过滤**：输入文字实时过滤标签
3. **选择分配**：唯一匹配时按Enter直接分配多个匹配时鼠标点击选择无匹配时自动进入创建流程
4. **批量操作**：支持连续为视频分配多个标签

## 内部逻辑

### 标签存储结构

```
{
  "tags": {
    "group1": {
      "tag_001": ImageTag,
      "tag_002": TextTag
    },
    "group2": {
      "tag_003": ImageTag
    }
  },
  "tag_index": {
    "keyword1": ["tag_001", "tag_002"],
    "keyword2": ["tag_003"]
  }
}
```

### 搜索算法

```
class TagSearch {
  async searchTags(query: string): Promise<Tag[]> {
    // 1. 分词处理
    const keywords = this.tokenizeQuery(query);
    
    // 2. 多维度搜索
    const results = await Promise.all([
      this.searchByName(keywords),
      this.searchByDescription(keywords),
      this.searchByGroup(keywords),
      this.searchByContent(keywords)
    ]);
    
    // 3. 结果合并与排序
    const merged = this.mergeResults(results);
    const ranked = this.rankResults(merged, keywords);
    
    return ranked;
  }
  
  private rankResults(tags: Tag[], keywords: string[]): Tag[] {
    return tags.sort((a, b) => {
      // 相关度评分算法
      const scoreA = this.calculateRelevanceScore(a, keywords);
      const scoreB = this.calculateRelevanceScore(b, keywords);
      
      return scoreB - scoreA; // 降序排列
    });
  }
}
```

### 数据关联管理

```
class TagAssociationManager {
  // 视频到标签的映射
  private videoToTags: Map<string, Set<string>> = new Map();
  
  // 标签到视频的映射  
  private tagToVideos: Map<string, Set<string>> = new Map();
  
  async associateTagWithVideo(tagId: string, videoHash: string): Promise<void> {
    // 更新视频到标签的映射
    if (!this.videoToTags.has(videoHash)) {
      this.videoToTags.set(videoHash, new Set());
    }
    this.videoToTags.get(videoHash)!.add(tagId);
    
    // 更新标签到视频的映射
    if (!this.tagToVideos.has(tagId)) {
      this.tagToVideos.set(tagId, new Set());
    }
    this.tagToVideos.get(tagId)!.add(videoHash);
    
    // 持久化存储
    await this.saveAssociations();
  }
}
```

## 文件与数据变化

### 元数据更新

```
{
  "video_hash": {
    "assigned_tags": ["tag_001", "tag_002", "tag_003"]
  }
}
```

### 标签数据存储

```
{
  "tag_001": {
    "tag_id": "tag_001",
    "tag_type": "image",
    "name": "人物特写",
    "group": "内容分类",
    "created_time": "2024-01-15T10:30:00Z",
    "video_files": ["video_hash_1", "video_hash_2"],
    "image_data": {
      "source_video": "video_hash_1",
      "timestamp": 123456789,
      "bounding_box": {"x": 100, "y": 150, "width": 200, "height": 120},
      "image_path": "files/video_hash_1/screenshots/123456789.png"
    },
    "descriptions": ["主角", "特写镜头", "重要时刻"]
  }
}
```

## 异常处理

### 数据一致性维护

```
class TagConsistencyChecker {
  async validateTagReferences(): Promise<ValidationReport> {
    const report: ValidationReport = {
      orphaned_tags: [],      // 无关联视频的标签
      missing_videos: [],     // 不存在的视频引用
      broken_image_links: []  // 图片路径失效
    };
    
    // 检查所有标签的关联视频是否存在
    for (const [tagId, tag] of this.allTags) {
      for (const videoHash of tag.video_files) {
        if (!await this.videoExists(videoHash)) {
          report.missing_videos.push({ tagId, videoHash });
        }
      }
      
      // 检查图片标签的截图文件
      if (tag.tag_type === 'image' && !await this.imageExists(tag.image_data.image_path)) {
        report.broken_image_links.push(tagId);
      }
    }
    
    return report;
  }
}
```

## 性能优化

### 标签索引构建

```
class TagIndexBuilder {
  private searchIndex: Map<string, Set<string>> = new Map();
  
  async buildSearchIndex(): Promise<void> {
    // 清空现有索引
    this.searchIndex.clear();
    
    // 为每个标签构建索引
    for (const [tagId, tag] of this.allTags) {
      const indexTerms = this.extractIndexTerms(tag);
      
      for (const term of indexTerms) {
        if (!this.searchIndex.has(term)) {
          this.searchIndex.set(term, new Set());
        }
        this.searchIndex.get(term)!.add(tagId);
      }
    }
  }
  
  private extractIndexTerms(tag: Tag): string[] {
    const terms: string[] = [];
    
    // 从名称中提取
    terms.push(...this.tokenize(tag.name));
    
    // 从分组中提取
    terms.push(...this.tokenize(tag.group));
    
    // 从描述中提取（图片标签）
    if (tag.tag_type === 'image') {
      for (const desc of tag.descriptions) {
        terms.push(...this.tokenize(desc));
      }
    }
    
    // 从文本内容中提取（文本标签）
    if (tag.tag_type === 'text') {
      terms.push(...this.tokenize(tag.text));
    }
    
    return [...new Set(terms)]; // 去重
  }
}
```

#### tags.json实例

```json
 [
    {
      "groupName": "风景",
      "tags": [
        {
          "id": 1,
          "texts": [ "日落", "海滩", "黄金时刻" ],
          "imagePath": "tag_images/1.jpg"
        },
        {
          "id": 5,
          "texts": [ "雪山", "清晨" ],
          "imagePath": "tag_images/5.jpg"
        }
      ]
    },
    {
      "groupName": "人物特写",
      "tags": [
        {
          "id": 2,
          "texts": [ "微笑", "特写镜头" ],
          "imagePath": "tag_images/2.png"
        }
      ]
    },
    {
      "groupName": "教程/代码演示",
      "tags": [
        {
          "id": 3,
          "texts": [ "Python代码示例" ],
          "imagePath": null
        }
      ]
    }
  ]
```