### 1. 统一数据结构

无论是“图片标签”还是“文本标签”，在底层存储上完全一致。区别仅在于 imagePath 字段是否有值。

**JSON 模型 (Tag Object):**

codeJSON



```
{
  "id": "Unique_ID (long/string)",
  "groupName": "分组名称 (String)",
  "texts": ["主关键词", "描述1", "描述2"], 
  "imagePath": "String (Nullable)" 
}
```

- 
- **texts**: 字符串数组。第一个元素通常作为主标签名显示，后续元素作为辅助描述或搜索关键词。
- **imagePath**:
  - 
  - 若为 **路径字符串**：视为 **图片标签**（显示截图预览）。
  - 若为 **null/空**：视为 **文本标签**（仅显示文字）。

------



### 2. 创建界面 UI 布局

对话框分为上下两个核心区域，旨在将“创建”与“检索”融合，防止用户重复创建已存在的标签。

#### 2.1 上半区域：输入与预览区 (Input Area)

用户在此处定义新标签的内容。

- 
- **左侧（媒体位）**：
  - 
  - **图片标签模式**：显示当前框选区域的截图预览。
  - **文本标签模式**：显示默认图标或留空。
- **右侧（表单位）**：
  - 
  - **描述输入框**：支持输入多个文本（对应 texts 数组）。
    - 
    - *交互*：输入完一个词按 Tab 或 Enter 生成一个 Chip（胶囊块），支持删除。
  - **分组选择器**：下拉框 + 输入框组合。
    - 
    - 支持选择现有分组，或直接输入新名称创建新分组。

#### 2.2 下半区域：实时过滤提示区 (Suggestion Area)

这是防止数据冗余的核心设计。

- 
- **触发逻辑**：监听上半区域“描述输入框”的每一次按键。
- **显示内容**：
  - 
  - 根据用户当前输入的关键词，实时遍历检索现有的所有标签（匹配 texts 和 groupName）。
  - 以列表或网格形式展示匹配到的**现有标签**（显示其缩略图、文字和所属分组）。
- **交互目的**：
  - 
  - **查重**：提示用户“库里可能已经有这个标签了”。
  - **快速复用**：如果用户发现下方出现了想要的标签，可以直接**点击**该标签。
    - 
    - *动作*：点击后，**放弃创建新标签**，直接将选中的**现有标签**分配给当前视频，并关闭对话框。

------



### 3. 操作流程 (Workflow)

#### 场景 A：创建全新的标签

1. 
2. **触发**：
   - 
   - (图片) 框选画面 -> 按快捷键。
   - (文本) 直接按快捷键。
3. **输入**：在顶部输入关键词（如“海边”）。
4. **观察**：下半区域显示“无匹配结果”或显示的内容与当前需求不符。
5. **完善**：输入分组（如“风景”），确认其他描述。
6. **提交**：按 Enter 或点击“创建并分配”。
7. **结果**：系统生成新 ID，保存到 JSON，并关联到当前视频。

#### 场景 B：复用现有标签（防重流程）

1. 
2. **触发**：用户想标记“海边”，触发创建框。
3. **输入**：用户在顶部刚输入“海”。
4. **发现**：下半区域实时刷新，跳出了一个已存在的标签（缩略图是之前的某次截图，文字包含“海滩、海边”，分组为“风景”）。
5. **决策**：用户意识到无需新建，直接**点击**下方的这个旧标签。
6. **结果**：对话框关闭，系统直接建立当前视频与该旧标签 ID 的关联。**不会产生新数据。**

### 4. 内部处理逻辑

1. 
2. **截图处理（仅图片标签）**：
   - 
   - 在对话框弹出前，系统先将框选区域的图像数据暂存（内存或临时文件）。
   - 只有当用户最终点击“创建新标签”时，才将图片正式保存到 tag_images/ 目录，并生成 imagePath。
   - 若用户选择了复用下方旧标签，则丢弃暂存的截图，节省磁盘空间。
3. **索引更新**：
   - 
   - 一旦新标签创建成功，TagIndexBuilder 需立即将新标签的 texts 和 groupName 加入搜索索引，确保下次搜索能立刻搜到。

### 5. 总结









| 区域       | 功能                          | 核心价值                                                     |
| ---------- | ----------------------------- | ------------------------------------------------------------ |
| **上半区** | 定义内容 (截图 + 文本 + 分组) | 生产数据，标准录入。                                         |
| **下半区** | 实时检索 (Search-as-you-type) | **数据清洗前置化**。在源头拦截重复标签，鼓励复用，维护标签库的整洁性。 |





### 1. 核心策略：标准化容器 + 智能填充 (Standardized Container)

无论原图是横屏（16:9）、竖屏（9:16）还是超宽屏，在 UI 上必须强制使用统一的容器尺寸，以保证列表的整齐。

#### 推荐方案：卡片式布局 (Card Layout)

适用于 **“分配标签菜单” (Shift+T)** 或 **“标签管理库”** 界面。

- **容器比例**：统一采用 **16:9** 或 **3:2** 的横向矩形（因为是视频管理软件，横向视觉更协调）。
- **填充模式 (Object-Fit)**：采用 cover (覆盖/裁切)。
  - **逻辑**：将图片等比缩放，填满容器，多余部分裁掉。
  - **定位**：默认 center center（居中）。
- **文字层**：在卡片底部叠加 **黑色半透明渐变蒙版**，白字显示标签名（如“富士山”）。

> **为何不使用缩放 (Contain)？**
> 如果使用 contain（显示全图，留黑边），对于细长的竖屏截图，中间只有一条细线，既看不清内容，也让界面显得破碎。cover 虽然会裁掉部分，但能保证视觉饱满。

------



### 2. 交互补偿机制 (Interaction & Compensation)

为了解决 cover 模式可能裁掉关键部位（比如把“人物”标签的头裁掉了）的问题，需要增加交互反馈。

#### A. 悬停全览 (Hover to Reveal)

- **操作**：当鼠标悬停在标签卡片上超过 0.3秒。
- **效果**：
  - **方案一（简单）**：图片在卡片内部缩小至全貌 (object-fit: contain)，背景显示高斯模糊的该图片。
  - **方案二（高级）**：弹出一个浮层（Tooltip），按原比例完整显示该图片（最大宽度限制在 300px 左右）。

#### B. 智能对齐 (Smart Alignment - 可选进阶)

如果在 files.json 或 tags.json 中允许记录额外数据，可以给图片增加一个 focus_point (关注点)。

- **默认**：Center (50% 50%)。
- **优化**：如果用户截的是竖屏全身像，系统默认居中可能只显示肚子。允许用户在设置标签封面时，简单点击一下“人脸位置”，记录 focus: "top"。CSS 中使用 object-position: top center;。

------



### 3. 不同场景的 UI 规范

根据标签出现的位置，采用不同的显示策略：

#### 场景 1：标签选择/管理网格 (Grid View)

- **适用**：按 Shift+T 唤出的面板。

- **样式**：**大卡片**。

- **布局**：

  codeCSS

  ```
  .tag-card {
    width: 160px;
    height: 90px; /* 16:9 */
    border-radius: 8px;
    overflow: hidden;
    position: relative;
  }
  .tag-image {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 关键属性 */
    transition: transform 0.2s;
  }
  .tag-card:hover .tag-image {
    transform: scale(1.1); /* 悬停微放大，增加由于感 */
  }
  ```

#### 场景 2：视频下方的已选标签 (Detail View)

- **适用**：视频播放界面下方的元数据栏。

- **样式**：**胶囊/芯片样式 (Chips)**。

- **布局**：

  - 左侧为圆形或圆角正方形头像（Avatar），右侧为文字。
  - 头像区域非常小（如 24x24px），强制使用 object-fit: cover。
  - 此时图片仅作为“图标”存在，主要靠文字识别。

  codeCSS

  ```
  .tag-chip {
    display: flex;
    align-items: center;
    background: #333;
    padding-right: 10px;
    border-radius: 16px;
  }
  .tag-chip img {
    width: 32px;
    height: 32px;
    border-radius: 50%; /* 圆形 */
    object-fit: cover;
    margin-right: 8px;
  }
  ```

------



### 4. 极端情况兜底 (Edge Cases)

有些用户截图可能极度不规范（例如 100x2000 的长条图，或者 50x50 的像素图）。

1. **图片缺失**：
   - 如果 tag_images 目录下找不到对应的 ID 图片。
   - **UI**：显示一个带有首字（如“风”）的纯色背景块，或者通用 Placeholder 图标。
2. **分辨率过低**：
   - CSS 设置 image-rendering: pixelated 避免模糊，或者接受模糊作为一种朦胧美。
3. **分辨率过高**：
   - 软件在加载标签图时，建议在内存中生成缩略图（Cache），不要直接渲染 4K 截图到 160px 的卡片上，否则几十个标签会导致界面卡顿。

### 5. 总结建议















| 功能点         | 建议方案                                              |
| -------------- | ----------------------------------------------------- |
| **默认显示**   | **16:9 卡片，CSS object-fit: cover (居中裁切)**       |
| **视觉一致性** | 强制统一宽高，底部叠加半透明黑色渐变以衬托白色文字    |
| **内容查看**   | **鼠标悬停 (Hover)** 时，在卡片上方浮出完整比例缩略图 |
| **列表模式**   | 使用 **圆形头像 + 文字** 的胶囊样式 (Chips)           |
| **技术实现**   | 纯 CSS 即可解决，无需复杂的 JS 裁剪算法               |