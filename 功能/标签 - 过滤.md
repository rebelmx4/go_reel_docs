#### 1. 组件概述 (Component Overview)

**通用标签过滤与展示组件**是标签系统的核心UI模块。它提供了一个统一的、可交互的界面，用于浏览、搜索和选择系统中的所有标签。

该组件被设计为一个纯粹的“展示”组件（Dumb Component）。它**不包含**任何业务逻辑输入框（如主关键词搜索框），而是通过外部传入的属性（Props）来控制其显示内容，并通过触发事件（Events）来向上层传达用户的操作。这种解耦的设计使其具备极高的可复用性和可预测性。

#### 2. 设计哲学 (Design Philosophy)

- **控制器分离 (Decoupled Controller)**：组件的过滤行为（如关键词搜索）完全由其父组件通过 props 控制。这使得父组件可以自由地将任何输入框与该组件的过滤逻辑绑定。
- **数据驱动 (Data-Driven)**：组件的显示状态完全取决于传入的 props。当 props 发生变化时，组件会自动重新渲染。它不维护自己复杂的内部状态，特别是关于哪些标签应该显示或隐藏的状态。
- **响应式交互 (Reactive Interaction)**：用户的操作（如点击一个标签）会通过事件的形式通知父组件，由父组件来决定如何更新数据，然后将更新后的数据作为新的 props 传回本组件，完成数据流的闭环。

#### 3. UI 布局与视觉元素 (UI Layout & Visual Elements)

组件采用经典的“左侧导航-右侧内容”布局，以在有限空间内提供最佳的浏览体验。

```
+----------------------------------------------------------------------------------+
| [ 📂 标签分组 ]                               | 📘 人物                           |
| +-----------------------------------------+ |     +----------+ +----------+    |
| | [ 🔍 过滤分组... ]                      | |     | [img]    | | [img] !  |    |
| +-----------------------------------------+ |     | 侧脸特写 | | 微笑     |    |
| | 🏞️ 风景                               | |     +----------+ +----------+    |
| | 📘 人物 (当前选中)                    | |                                 |
| | 🎬 影视                               | | 🏞️ 风景                           |
| | ... (可滚动) ...                        | |     +----------+ +----------+    |
| +-----------------------------------------+ |     | [img] !  | | [img]    |    |
|                                             |     | 富士山   | | 海滩     |    |
| (左侧分组列表)                              |     +----------+ +----------+    |
|                                             |                                 |
|                                             | (右侧瀑布流式标签网格 - 可滚动)   |
+----------------------------------------------------------------------------------+
```

- **左侧：标签分组导航 (Left Pane)**
  - **分组过滤器**: 列表顶部有一个独立的输入框，用于快速筛选分组列表本身。
  - **分组列表**: 垂直展示所有标签分组。点击某个分组，右侧内容区会平滑滚动定位到对应的分组标题。当前视口内的分组在列表中应有高亮状态。
- **右侧：标签网格区 (Right Pane)**
  - **布局**: 采用“分组标题”+“标签网格”的连续瀑布流布局。
  - **标签卡片 (Tag Card)**: 标签的最小单元。
    - **封面**: 显示标签图片 ([tag_id].webp)。
    - **关键词**: 显示在图片下方。
    - **描述指示器 (!)**: 若标签有描述，在封面左上角显示感叹号图标。
    - **悬停交互**: 鼠标悬停在卡片上时，若有描述，则弹出浮层（Tooltip）展示完整的描述文本。

#### 4. API & Props (接口与属性)

这是组件的输入接口，父组件通过这些属性来控制其行为和显示。

| Prop Name      | Type        | Required | Description                                                  |
| -------------- | ----------- | -------- | ------------------------------------------------------------ |
| all_tags_data  | Object      | true     | 包含所有标签数据的完整对象，通常是按分组嵌套的结构。         |
| filter_keyword | String      | false    | **外部**传入的过滤关键词。组件将根据此字符串过滤标签的 keywords 和 description 字段。默认为空字符串。 |
| excluded_ids   | Set<Number> | false    | 一个包含标签ID的集合。所有ID在此集合中的标签将**不会**被显示，即使它们匹配过滤条件。默认为空集合。 |

#### 5. 交互事件 (Emitted Events)

这是组件的输出接口，它通过这些事件与父组件通信。

| Event Name | Payload        | Description                                    |
| ---------- | -------------- | ---------------------------------------------- |
| tag-click  | {id, keywords} | 当用户单击右侧网格中的任意一个标签卡片时触发。 |

#### 6. 核心逻辑：动态显示与隐藏

这部分详细阐述了组件如何处理“排除”和“重新显示”标签的逻辑，这对于“分配标签”等界面至关重要。

**核心机制**：组件本身是**无状态**的。一个标签是否显示，仅取决于它是否同时满足以下两个条件：

1. 其ID**不**在传入的 excluded_ids 集合中。
2. 其内容匹配传入的 filter_keyword。

**“重新显示”一个被取消分配的标签的流程 (以“分配标签”弹窗为例):**

这个流程完美地展示了数据驱动的设计思想：

1. **初始状态**:
   - “分配标签”弹窗维护一个 assigned_tags 列表，其中包含已分配给当前视频的标签。
   - 弹窗将 assigned_tags 列表中的所有标签ID作为 excluded_ids 这个 prop 传给下方的“通用标签过滤与展示组件”。
   - 因此，过滤组件**不会显示**任何已分配的标签。
2. **用户操作**:
   - 用户在弹窗上方的“已分配标签”区域，点击了标签 A 旁边的 ⓧ (取消分配) 按钮。
3. **父组件响应 (弹窗)**:
   - 弹窗监听到这个点击事件。
   - 它从自己的 assigned_tags 列表中**移除**标签 A。
   - 因为 excluded_ids 是 assigned_tags 的一个计算属性，所以 excluded_ids 集合也**自动更新**，不再包含标签 A 的ID。
4. **组件重新渲染 (数据驱动)**:
   - 由于 excluded_ids 这个 prop 发生了变化，框架（如Vue/React）会触发“通用标签过滤与展示组件”的重新渲染。
   - 在新的渲染周期中，组件进行判断：
     - 标签 A 的ID是否在新的 excluded_ids 集合中？**否**。
     - 标签 A 是否匹配当前的 filter_keyword？(假设匹配) **是**。
   - 两个条件都满足，因此标签 A 现在**重新出现**在下方的标签网格中。

**结论**：我们不需要“告诉”过滤组件去显示某个标签。我们只需要改变它的输入数据 (excluded_ids)，它就会作为这个数据变化的自然结果，自动、正确地更新自己的视图。这个流程清晰、可预测且易于维护。