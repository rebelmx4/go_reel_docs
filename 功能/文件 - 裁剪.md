### 1. 痛点与动机

- 
- **痛点**：
  - 
  - 许多视频（如录播、长镜头）只有部分片段有价值，原始文件占用大量磁盘空间。
  - 传统的剪辑软件流程繁琐（导入-剪辑-渲染-导出），不适合快速处理大量视频。
  - 误删片段可能导致包含重要截图的高光时刻丢失。
- **动机**：
  - 
  - 提供**“原地轻量级剪辑”**：在播放器内直接完成分段和筛选。
  - **有损/破坏性导出**：最终生成的视频是经过裁剪的合并版，直接替换（或继承）原文件的身份。
  - **智能元数据迁移**：确保裁剪后，原视频的截图、封面、标签等数据能自动适配新的视频内容。

### 2. 功能概要

- 
- **可视化轨道**：在播放控制区下方显示一条代表视频总时长的长条区域。
- **非线性编辑**：通过快捷键 Q 切割，双击切换保留/删除状态。
- **合并导出**：一键将所有“保留”的片段合并成新视频，自动处理旧文件和元数据。
- **截图保护与迁移**：防止误删截图片段，并自动校准保留下来的截图的时间戳文件名。

### 3. UI 布局与交互

#### 3.1 裁剪轨道 (Clip Track)

- 
- **位置**：播放控制区下方。
- **显示逻辑**：
  - 
  - 默认隐藏或收起。
  - 激活时，**播放控制区整体上移**，**视频视口（Viewport）适当缩小**以腾出空间。
- **初始状态**：显示为一个完整的 Clip（片段），代表整个视频。
- **片段状态**：
  - 
  - **保留 (Keep)**：正常高亮显示（默认状态）。
  - **删除 (Remove)**：置灰或显示删除线纹理（互斥状态）。
- **进度联动**：单击轨道上的任意片段，视频进度跳转到该片段的起始时间（不改变暂停/播放状态）。

#### 3.2 视觉反馈

- 
- **警告 Icon**：如果一个被标记为“删除”的片段区间内包含已保存的截图，该片段上显示一个**黄色的警告图标**。
- **悬浮预览**：鼠标悬停在警告图标上时，显示该片段内包含的截图（最多 3 张），提示用户这里有重要内容。

### 4. 快捷键与操作逻辑

- 
- **分割 (Q 键)**：
  - 
  - 在当前播放时间点，将所在的 Clip 一分为二。
- **状态切换 (双击)**：
  - 
  - 双击 Clip，在“保留”和“删除”状态间切换。
- **合并 (Delete 键)**：
  - 
  - 选中一个 Clip，按下 Delete，该 Clip 会被移除，其区域与**右侧**的 Clip 合并。
  - **状态继承**：合并后的新 Clip 继承**左侧** Clip 的状态（保留/删除）。
  - **边界处理**：
    - 
    - 若是**最开头**的 Clip：向右合并。
    - 若是**最末尾**的 Clip：向左合并。

### 5. 执行裁剪与导出流程

轨道最右端设有 **“执行”** 按钮，点击后触发以下严密的逻辑链：

#### 5.1 预检查 (Pre-check)

1. 
2. **扫描截图冲突**：检查所有标记为“删除”的片段中是否存在截图。
   - 
   - **若存在**：**禁止执行**（或强阻断），弹窗提示“无法裁剪：待删除片段中包含 x 张截图，请先处理截图或保留片段”。
3. **用户确认**：若无冲突，弹出确认框：“将对视频进行裁剪合并，原文件将移入已编辑目录，确认？”。

#### 5.2 视频处理 (Processing)

1. 
2. **拼接**：提取所有标记为“保留”的片段，按时间顺序无缝拼接。
3. **归档旧文件**：将原始视频文件移动到 setting.json 配置的 edited_path（已编辑目录）。
4. **保存新文件**：将生成的视频以**原文件名**保存到**原路径**。

#### 5.3 数据迁移与时间轴校准 (Metadata & Timeline)

由于视频内容变了，Hash 会变，时间轴也会变，必须进行“数据外科手术”：

1. 
2. **哈希计算**：计算新视频的 Hash 值（New_Hash）。
3. **元数据迁移**：
   - 
   - 读取 files.json 中原 Hash（Old_Hash）的数据。
   - 将数据（标签、评分、点赞数等）绑定到 New_Hash。
   - 如果原视频在“待删除”目录找不到（已被移走），清除 Old_Hash 的旧条目。
4. **封面迁移**：
   - 
   - 将 covers/Old_Hash.jpg 重命名为 covers/New_Hash.jpg。
   - 将 covers/Old_Hash_d.jpg 重命名为 covers/New_Hash_d.jpg。
5. **截图目录迁移**：
   - 
   - 将 data/screenshot/Old_Hash/ 文件夹重命名为 data/screenshot/New_Hash/。
6. **截图文件名重命名（时间轴校准）**：
   - 
   - **问题**：原截图名为 i_120000.webp（第120秒），如果剪掉了前 60秒，新视频中该画面出现在第 60秒，文件名需修正为 i_60000.webp。
   - **算法**：
     - 
     - 遍历所有“保留”的片段。
     - 记录每个保留片段之前的**累计删除时长**（Offset）。
     - 遍历该片段内的所有截图：新文件名时间戳 = 旧文件名时间戳 - 累计删除时长。
     - 执行重命名操作。

### 6. Setting 配置

- 
- **配置文件** (setting.json)：
  - 
  - edited_path: (String) 存放被裁剪掉原始文件的目录（“后悔药”目录）。

### 7. 流程图：裁剪执行逻辑

codeMermaid



```
graph TD
    A[点击执行按钮] --> B{待删除片段有截图?}
    B -- 有 --> C[阻断操作/提示无法裁剪]
    B -- 无 --> D[弹出确认框]
    D -- 确认 --> E[FFmpeg 拼接保留片段]
    
    E --> F[原视频移至 edited_path]
    F --> G[新视频写入原路径]
    G --> H[计算新 Hash]
    
    H --> I[迁移 files.json 元数据]
    I --> J[重命名封面文件 Old->New]
    J --> K[重命名截图文件夹 Old->New]
    
    K --> L[遍历保留片段]
    L --> M[计算时间轴偏移量 Offset]
    M --> N[重命名截图文件: OldTime - Offset]
    
    N --> O[裁剪完成，刷新界面]
```