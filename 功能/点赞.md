## 解决的问题

1. **价值量化需求**：为用户提供量化视频价值的直观方式
2. **内容筛选需求**：快速识别和定位高价值视频内容
3. **长期价值评估**：区分"一时好看"与"经得起重复观看"的内容
4. **个性化排序**：基于个人喜好而非客观指标的内容优先级

## 功能说明

### 核心特性

- **每次观看可点赞**：同一视频在不同观看会话中可重复点赞
- **累计计数机制**：点赞次数反映视频的长期重复价值
- **无状态切换**：点赞/取消点赞的即时反馈
- **跨会话持久化**：点赞数据永久保存，支持长期价值评估

### 数据特性

- **显式用户意图**：只有主动点击才记录，避免被动统计
- **时间维度记录**：记录每次点赞的时间戳（用于趋势分析）
- **独立于播放统计**：与播放次数、观看时长等解耦

## UI设计

### 界面元素

```
[♥️ 点赞按钮] - 心形图标 + 数字计数显示
   ↑
交互反馈：点击动画 + 即时计数更新
```

### 视觉状态

- **未点赞状态**：空心心形 ♡ + 灰色计数
- **已点赞状态**：实心心形 ♥️ + 高亮计数（如红色）
- **点击动画**：缩放效果 + 数字变化动画
- **悬停效果**：按钮高亮，提示"点赞"或"取消点赞"

### 布局位置

位于控制栏的功能区，与其他交互按钮相邻：

```
[步进模式] [视频旋转] [截图旋转] [♥️ 点赞数] [音量控制] [跳帧模式]
```

## 操作流程

### 基本交互

1. **点击点赞**：当前未点赞 → 点赞计数+1，切换为已点赞状态当前已点赞 → 点赞计数-1，切换为未点赞状态
2. **状态反馈**：即时显示数字变化（+1/-1动画）心形图标状态切换轻微震动或缩放效果增强反馈
3. **数据保存**：异步保存到`files.json`，不影响当前操作失败时提供重试机制，但UI状态立即更新

### 快捷键支持

```
const LIKE_HOTKEYS = {
  TOGGLE_LIKE: 'F',        // 点赞/取消点赞
  // 与其他快捷键协调，避免冲突
};
```

## 内部逻辑

### 数据结构

```
interface LikeData {
  total_count: number;           // 总点赞次数
  like_sessions: LikeSession[];  // 每次点赞的详细记录
  last_liked?: Date;            // 最后一次点赞时间
}

interface LikeSession {
  timestamp: Date;              // 点赞时间
  session_id?: string;          // 观看会话ID（可选）
  video_timestamp: number;     // 视频时间点（毫秒）
}
```

### 点赞处理逻辑

```
class LikeManager {
  private likeData: Map<string, LikeData> = new Map();
  
  async toggleLike(videoId: string): Promise<LikeResult> {
    const currentData = this.likeData.get(videoId) || this.createDefaultLikeData();
    const wasLiked = currentData.total_count > 0;
    
    if (wasLiked) {
      // 取消点赞
      currentData.total_count--;
      currentData.like_sessions = currentData.like_sessions.slice(0, -1);
    } else {
      // 点赞
      currentData.total_count++;
      currentData.like_sessions.push({
        timestamp: new Date(),
        video_timestamp: this.getCurrentVideoTime(),
        session_id: this.currentSessionId
      });
      currentData.last_liked = new Date();
    }
    
    // 更新内存状态
    this.likeData.set(videoId, currentData);
    
    // 异步保存到持久化存储
    await this.saveLikeData(videoId, currentData);
    
    return {
      success: true,
      new_count: currentData.total_count,
      action: wasLiked ? 'unliked' : 'liked'
    };
  }
  
  private async saveLikeData(videoId: string, data: LikeData): Promise<void> {
    // 确保视频在files.json中有记录
    await this.ensureVideoMetadataExists(videoId);
    
    // 更新点赞数据
    await this.updateFilesJson(videoId, {
      like_count: data.total_count,
      like_sessions: data.like_sessions,
      last_liked: data.last_liked
    });
  }
}
```

### 元数据触发逻辑

```
class MetadataManager {
  async ensureVideoMetadataExists(videoId: string): Promise<void> {
    // 检查是否已存在元数据记录
    const existingMetadata = await this.getVideoMetadata(videoId);
    
    if (!existingMetadata) {
      // 首次点赞时创建元数据记录
      await this.createInitialMetadata(videoId, {
        like_count: 1,
        // 其他基础字段...
        created_at: new Date(),
        created_by: 'like_action'
      });
    }
  }
}
```

## 文件与数据变化

### 元数据更新

```
{
  "video_hash": {
    "like_count": 5,                    // 总点赞次数
    "like_sessions": [                  // 点赞历史记录
      {
        "timestamp": "2024-01-15T10:30:00Z",
        "video_timestamp": 123456,
        "session_id": "sess_abc123"
      }
    ],
    "last_liked": "2024-01-20T15:45:00Z", // 最后点赞时间
    "first_liked": "2024-01-10T09:15:00Z" // 首次点赞时间
  }
}
```

### 数据持久化规则

- **首次点赞**：创建视频的元数据条目，包含点赞信息
- **后续点赞**：更新现有元数据中的点赞计数和历史
- **取消点赞**：减少计数，但保留历史记录（用于分析）
- **数据完整性**：点赞操作是原子性的，确保数据一致性

## 与其他功能的关系

### 与点赞页面的关系

```
class LikePageManager {
  async getLikedVideos(): Promise<LikedVideo[]> {
    // 从files.json中获取所有有点赞记录的视频
    const allMetadata = await this.loadAllMetadata();
    
    return allMetadata
      .filter(meta => meta.like_count > 0)
      .sort((a, b) => b.like_count - a.like_count) // 按点赞数降序
      .map(meta => this.createLikedVideoDisplayItem(meta));
  }
}
```

### 与播放列表的关系

- **排序影响**：点赞次数作为智能排序的权重因子
- **内容发现**：高点赞视频在推荐中有更高优先级
- **个人化**：点赞数据用于构建用户兴趣画像

### 与统计系统的关系

```
// 点赞数据的分析价值
interface LikeAnalytics {
  popular_videos: VideoRanking[];     // 热门视频排名
  trending_videos: VideoTrend[];      // 近期受欢迎视频
  personal_taste: TasteProfile;       // 用户口味分析
  content_quality: QualityMetrics;    // 内容质量评估
}
```

## 异常处理

### 边界情况处理

1. **并发点赞**：防止重复计数，使用乐观锁或事务
2. **数据损坏**：点赞计数与历史记录不一致时的修复
3. **存储失败**：网络或磁盘错误时的重试机制
4. **元数据缺失**：点赞时发现元数据丢失的恢复流程

### 错误恢复

```
class LikeRecovery {
  async recoverFromCorruption(videoId: string): Promise<void> {
    // 1. 从操作日志重建点赞计数
    const operations = await this.getLikeOperations(videoId);
    const reconstructedCount = operations.filter(op => op.type === 'like').length;
    
    // 2. 验证与当前数据的一致性
    const currentData = await this.getLikeData(videoId);
    if (currentData.total_count !== reconstructedCount) {
      await this.repairLikeData(videoId, reconstructedCount);
    }
    
    // 3. 记录修复操作
    await this.auditRecoveryOperation(videoId, 'like_data_repaired');
  }
}
```

## 性能优化

### 内存管理

```
class LikeCache {
  private cache: Map<string, LikeData> = new Map();
  private maxCacheSize = 1000;
  
  getLikeData(videoId: string): LikeData | undefined {
    // LRU缓存策略
    if (this.cache.has(videoId)) {
      const data = this.cache.get(videoId)!;
      // 移动到最近使用
      this.cache.delete(videoId);
      this.cache.set(videoId, data);
      return data;
    }
    return undefined;
  }
  
  setLikeData(videoId: string, data: LikeData): void {
    if (this.cache.size >= this.maxCacheSize) {
      // 移除最久未使用的项目
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(videoId, data);
  }
}
```

### 存储优化

```
// 定期清理过期的点赞会话数据
async cleanupOldLikeSessions(): Promise<void> {
  const cutoffDate = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000); // 1年前
  
  for (const [videoId, data] of this.likeData) {
    const filteredSessions = data.like_sessions.filter(
      session => new Date(session.timestamp) > cutoffDate
    );
    
    if (filteredSessions.length !== data.like_sessions.length) {
      await this.updateLikeSessions(videoId, filteredSessions);
    }
  }
}
```